module stmt

imports

  base
  env
  expr
  sec

signature

  relations
    return: LTYPE

rules

  stmtListOk: Env * list(Stmt) -> Env
  stmtsOk: Env * Stmts -> Env

  stmtsOk(ENV, Stmts(stmts)) = ENV' :-
    stmtListOk(ENV, stmts) == ENV'.

  stmtListOk(ENV, []) = ENV.

  stmtListOk(ENV, [s | ss]) = ENV'' :- {ENV'}
    stmtOk(ENV, s) == ENV',
    stmtListOk(ENV', ss) == ENV''.

rules

  stmtOk: Env * Stmt -> Env

  stmtOk(ENV, AssignExpr(s, x, e)) = ENV' :- {T T'}
    typeOfExpr(ENV, e) == T,
    secCompat(ENV, s, T) == T',
    update(ENV, x, T') == ENV'.

  // Control Flow
  stmtOk(ENV, While(e, ss)) = ENV :- {S ENV'}
    typeOfExpr(ENV, e) == (BOOL(), S),
    updateFlowSensitivity(ENV, S) == ENV',
    stmtsOk(ENV', ss) == _.

  stmtOk(ENV, IfThenElse(e, ss1, ss2)) = ENV :- {S ENV'}
    typeOfExpr(ENV, e) == (BOOL(), S),
    updateFlowSensitivity(ENV, S) == ENV',
    stmtsOk(ENV', ss1) == _,
    stmtsOk(ENV', ss2) == _.

  // Arrays
  stmtOk(ENV, NewArray(s, x, e)) = ENV' :- {T T' S}
    typeOfExpr(ENV, e) == T,
    secCompat(ENV, s, T) == (INT(), S),
    update(ENV, x, (ARRAY(_), S)) == ENV'. // Note: Array Element Type Inferred Later!

  stmtOk(ENV, ReadArray(s, x, x', e)) = ENV' :- {T T' S_x S_e S}
    get(ENV, x') == (ARRAY(T), S_x),
    typeOfExpr(ENV, e) == (INT(), S_e),
    or(S_x, S_e) == S,
    secCompat(ENV, s, (T, S)) == T',
    update(ENV, x, T') == ENV'.

  stmtOk(ENV, WriteArray(x, e_idx, e_val)) = ENV' :- {T S_x S_e S}
    get(ENV, x) == (ARRAY(T), S_x),
    typeOfExpr(ENV, e_idx) == (INT(), S_e),
    or(S_x, S_e) == S,
    typeOfExpr(ENV, e_val) == (T, S).

  // Return
  stmtOk(ENV, Return(e)) = ENV :- {T S S'}
    returnType(ENV) == (T, S)
    | error $[Return value has incompatible type or security label.],
    typeOfExpr(ENV, e) == (T, S'),
    assignCompat(S, S').

  stmtOk(ENV, AssingFunCall(s, x, f, Args(args))) = ENV' :- {T_args T_ret T_ret'}
    getFunc(ENV, f) == FUNTYPE(T_args, T_ret),
    argsOk(ENV, args, T_args),
    secCompat(ENV, s, T_ret) == T_ret',
    update(ENV, x, T_ret') == ENV'.

rules

  secCompat: Env * Sec * LTYPE -> LTYPE

  secCompat(ENV, s, (T, S)) = (T, S') :-
    S' == or(secOfSec(s),
             or(flowSensitivity(ENV), S)
          ).

rules

  returnType: Env -> LTYPE
  returnType(ENV) = T :-
    query return
      filter P*
      in ENV |-> [(_, T)].

rules

  getFunc: Env * FunName -> FUNTYPE
  argOk: Env * Expr * LTYPE
  argsOk maps argOk(*, list(*), list(*))
  
  getFunc(ENV, x) = TF :- {x'}
    query fun
      filter P*
        and { x' :- x' == x }
      in ENV |-> [(_, (x', TF))],
    @x.ref := x',
    @x.type := TF.

  argOk(ENV, e, T) :-
    typeOfExpr(ENV, e) == T.

rules

  updateFlowSensitivity: Env * SEC -> Env
  updateFlowSensitivity(ENV, LOW()) = ENV.
  updateFlowSensitivity(ENV, HIGH()) = ENV' :-
    new ENV',
    ENV' -P-> ENV,
    !flowSensitive[] in ENV'.